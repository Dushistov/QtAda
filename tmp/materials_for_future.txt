Как можно будет симулировать нажатие на объект:
    QByteArray subString = "mousearea";
    QByteArray teststr = metaObj->className();
    bool containsSubstring = teststr.toLower().contains(subString.toLower());
    if (containsSubstring) {
        QQuickItem *mouseArea = qobject_cast<QQuickItem*>(obj);
        qreal width = mouseArea->width();
        qreal height = mouseArea->height();
        // Вычисление координат центра
        QPointF centerPos(width / 2, height / 2);
        QMouseEvent pressEvent(QEvent::MouseButtonPress, centerPos, Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
        QMouseEvent releaseEvent(QEvent::MouseButtonRelease, centerPos, Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
        QCoreApplication::sendEvent(mouseArea, &pressEvent);
        QCoreApplication::sendEvent(mouseArea, &releaseEvent);
    }


Как решить проблему с тем, что диалог тестируемого приложения перекрывает ControlDialog:
    ->  Можно попробовать перехватывать создание диалогов в Probe::addObject и делать их не модальными: setWindowModality(Qt::NonModal);

Как решить проблему с тем, что мы не можем показать ControlDialog для QML:
    ->  Нужно перехватывать создание QQmlApplicationEngine и подгружать туда свой QML-код, который будет являться копией диалога на QtWidgets
